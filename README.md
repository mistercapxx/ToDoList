Explanation


*showContent(content) - для обработки отображения контента на основе переданного ему содержимого параметра.

1. const titleElement = document.querySelector('.top-center-text'); - Эта строка выбирает элемент HTML с именем класса «top-center-text» и присваивает его переменной titleElement.
2. Функция проверяет значение параметра content, чтобы определить, какой контент отображать: Если содержимое имеет значение «Сегодня», текстовое содержимое элемента titleElement изменяется на «Сегодня». Если содержимое имеет значение «Входящие», текстовое содержимое элемента titleElement изменяется на «Входящие».
3. const storedInfo = localStorage.getItem('storedInfo'); -Эта строка извлекает данные из localStorage с ключом storeInfo. Он проверяет, есть ли сохраненная информация, и присваивает ее переменной StoreInfo. Если сохраненной информации нет, для infoArray устанавливается пустой массив.
4. const infoArray = storedInfo ? JSON.parse(storedInfo) : []; - Эта строка проверяет, есть ли какая-либо сохраненная информация (storedInfo) в localStorage. Если да, он анализирует сохраненную строку JSON в массив с помощью JSON.parse(). Если сохраненной информации нет, инициализируется пустой массив [].
5. const container = document.querySelector('.container'); container.innerHTML = ''; - Этот код выбирает HTML-элемент с именем класса «контейнер» и очищает его содержимое, устанавливая для его внутреннего HTML пустую строку.
6.  В зависимости от параметра контента:       Если содержимое имеет значение «Сегодня», он фильтрует массив infoArray, чтобы получить информацию, включающую слово «сегодня» (без учета регистра), с помощью метода filter(). Затем он вызывает функцию displayFilteredContent(filteredInfo,Container) для отображения отфильтрованного содержимого в контейнере и обновляет заголовок на «Сегодня» с помощью функции updateTitle('Today').         Если содержимым является «Входящие», он отображает всю информацию в infoArray в контейнере с помощью displayFilteredContent(infoArray,Container) и обновляет заголовок до «Входящие» с помощью функции updateTitle('Inbox').

*updateTitle(titleText) отвечает за обновление текста заголовка и применение некоторых стилей к определенному элементу HTML.

*displayFilteredContent(filteredInfo,Container) отвечает за отображение отфильтрованной информации в указанном контейнере на веб-странице.
* if (filteredInfo.length > 0) { -Это условие проверяет, есть ли элементы в массиве filteredInfo (который содержит отфильтрованную информацию).

Внутри условия :
const ul = document.createElement('ul'); - создает элемент неупорядоченного списка (<ul>) с помощью document.createElement(). Этот список будет содержать отфильтрованные задачи или информацию.

filteredInfo.forEach(info => { — циклически перебирает каждый элемент массива filteredInfo.

const li = document.createElement('li'); -  создает элемент списка (<li>) для каждой части информации в отфильтрованном массиве.

li.textContent =info; — текстовое содержимое элемента списка (<li>) будет соответствовать текущей части информации из массива filteredInfo.

li.addEventListener('click', function() { — добавляет событие щелчка к каждому элементу списка.

This.remove - При щелчке по элементу списка выбранный элемент списка удаляется из отображаемого списка (<ul>).

updateStoredInfo(); -  для обновления localStorage после удаления элемента.

ul.appendChild(li); - добавляет каждый элемент списка в неупорядоченный список (<ul>).

Container.appendchild(ul); — добавляет полный неупорядоченный список со всеми элементами списка в указанный контейнер на веб-странице.

else {Container.textContent = ‘No tasks’; } — Если в массиве filteredInfo нет задач, для текстового содержимого контейнера устанавливается значение «Нет задач».

* event listener к событию DOMContentLoaded, которое срабатывает, когда  HTML-документ полностью загружен и проанализирован
1. Выбираем плюс баттон
2. Добавляем ивент лисенер к плюс батон
3. const info = Prompt - диалоговое окно с запросом ввода. Введенное значение сохраняется в переменной info.
4. if (info !== null && info.trim() !== '') { ... } — проверяет, не является ли введенная информация нулевой, и не просто пробелами
5. Внутри блока : извлекаем сохраненную инфу («storedInfo») из localStorage, передаем ее в массив (infoArray) или инициализируем пустой массив, если сохраненной информации нет.  Инфа пользователя добавляется в infoArray с помощью infoArray.push(info).  Обновленный infoArray сохраняется обратно в localStorage в виде строки JSON ( localStorage.setItem('storedInfo', JSON.stringify(infoArray)).
6. Вызываем функцию showContent('Inbox') для отображения содержимого папки «Входящие» после добавления новой информации. Прошу заметить я не обрабатывал Today, он записан по дефолту на странице.

Дальше по клику мы можем убрать элемент из списка по нажатию, для этого используем ивент лисенер :

if (event.target.tagName === 'LI') { ... } — это условие проверяет, имеет ли выбранный элемент (доступ к которому осуществляется через event.target) имя тега «LI», указывающее, что это элемент списка.

Внутри блока условий:

событие.target.remove(); - Если выбранный элемент является «LI», он удаляет этот конкретный элемент списка из DOM при нажатии.

updateStoredInfo(); - для обновления localStorage после удаления элемента списка.

1. const lis = document.querySelectorAll('.container ul li'); — Эта строка выбирает все элементы списка (<li>), которые являются потомками (<ul>) внутри элементов, имеющих класс «container». Выбранные элементы списка присваиваются переменной lis.
2. const infoArray = Array.from(lis).map(li => li.textContent); -  Преобразуем (lis) в массив с помощью Array.from().  метод map() для создания нового массива infoArray, содержащего текстовое содержимое каждого элемента списка. Этот массив представляет текущую информацию, отображаемую в виде элементов списка на странице.
3. localStorage.setItem('storedInfo', JSON.stringify(infoArray)); — Эта строка сохраняет infoArray в виде строки JSON в localStorage под ключом «storedInfo». Он использует JSON.stringify() для преобразования массива в строку JSON перед сохранением его в localStorage.



По CSS :

* top: 0; left: 0; width: 100%; height: 100% - покрывает все окно просмотра.
* z-index: -1;: Помещает элемент позади других элементов.
* Image display block - Отображает изображение как элемент уровня блока.
* word-wrap: Break-Word;: позволяет разбивать длинные слова и переносить их на следующую строку.
* ::before - создания визуального элемента перед содержимым:


